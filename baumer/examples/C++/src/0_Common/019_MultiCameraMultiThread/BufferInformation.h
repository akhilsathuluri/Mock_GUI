/* Copyright 2019-2020 Baumer Optronic */
#ifndef _BUFFER_INFORMATION_
#define _BUFFER_INFORMATION_

#include <thread>
#include <vector>
#include <mutex>
#include <list>
#include <string>

#include "bgapi2_genicam/bgapi2_genicam.hpp"

// structure which holds additional information
// transferred together with the camera buffer
// this structure should be adapted to needs of the application
struct BufferInformation{
    BufferInformation() {
        Reset();
    }
    void Reset() {
        valid = false;
        frameid = 0;
        frameid_sensor = 0;
        supports_frameid_sensor = false;
        is_imcomplete = false;
        camera_buffer_ts = 0;
        camera_buffer_ts_freq = 0;
        camera_buffer_ts_diff = 0.0f;
        camera_buffer_ts_diff_min = 0.0f;
        camera_buffer_ts_diff_max = 0.0f;
        camera_buffer_ts_diff_ave = 0.0f;
        host_buffer_ts = 0;
        host_buffer_ts_diff = 0.0f;
        host_buffer_ts_diff_min = 0.0f;
        host_buffer_ts_diff_max = 0.0f;
        host_buffer_ts_diff_ave = 0.0f;
        getfilled_buffer_ts = 0;
        getfilled_buffer_ts_diff = 0.0f;
        getfilled_buffer_ts_diff_min = 0.0f;
        getfilled_buffer_ts_diff_max = 0.0f;
        getfilled_buffer_ts_diff_ave = 0.0f;
        resend_valid = false;
        resend_requests = 0;
        resend_requests_single = 0;
        resend_requests_range = 0;
    }
    // flag which indicates, if the struct was filled with valid data by an incomming buffer
    bool valid;
    // buffer id of the software buffer object
    std::string bufferid;
    // frame id of the image generated by camera interface
    bo_uint64 frameid;
    // frame id of the image generated by camera sensor
    bo_uint64 frameid_sensor;
    // flag to indicate if the sensor frame id is supported
    bool supports_frameid_sensor;
    // flag to indicate if the buffer was completly received
    bool is_imcomplete;
    // time stamp of the image at the time of acquisition in the camera
    bo_uint64 camera_buffer_ts;
    // frequency of camera time stamp 1/camera_buffer_ts_freq Hz
    bo_uint64 camera_buffer_ts_freq;
    // time difference between two consecutive images
    double camera_buffer_ts_diff;
    // minmal time difference between two consecutive images
    double camera_buffer_ts_diff_min;
    // minmal time difference between two consecutive images
    double camera_buffer_ts_diff_max;
    // average time difference between two consecutive images
    double camera_buffer_ts_diff_ave;
    // timestamp at the time when receiving the first data block of the on the host
    bo_uint64 host_buffer_ts;
    // time difference between two consecutive images
    double host_buffer_ts_diff;
    // minmal time difference between two consecutive images
    double host_buffer_ts_diff_min;
    // minmal time difference between two consecutive images
    double host_buffer_ts_diff_max;
    // average time difference between two consecutive images
    double host_buffer_ts_diff_ave;
    // timestamp at the time when receiving the first data block of the on the host
    bo_uint64 getfilled_buffer_ts;
    // time difference between two consecutive images
    double getfilled_buffer_ts_diff;
    // minmal time difference between two consecutive images
    double getfilled_buffer_ts_diff_min;
    // minmal time difference between two consecutive images
    double getfilled_buffer_ts_diff_max;
    // average time difference between two consecutive images
    double getfilled_buffer_ts_diff_ave;
    // flag to indicate the use of resend statistic
    bool resend_valid;
    // statistic value, number of resend requests
    bo_int64 resend_requests;
    // statistic value, number resend requests requesting a single data packet
    bo_int64 resend_requests_single;
    // statistic value, number of resend requests requesting a bunch of data packet
    bo_int64 resend_requests_range;
};

#endif  // _BUFFER_INFORMATION_
